{"meta":{"title":"塔斯特曼-个人博客","subtitle":null,"description":null,"author":"wangyining","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Redis数据结构","slug":"Redis数据结构","date":"2019-01-04T16:46:03.000Z","updated":"2019-01-04T16:48:27.619Z","comments":false,"path":"2019/01/05/Redis数据结构/","link":"","permalink":"http://yoursite.com/2019/01/05/Redis数据结构/","excerpt":"","text":"redis都有哪些数据类型？分别在哪些场景下使用比较合适？】 redis主要有以下几种数据类型：string；hash；list；set；sortedset。 string：这是最简单的类型，就是普通的set和get，做简单的KV缓存。 hash：这个是类似map的一种结构，这个一般就是可以将结构化的数据，比如一个对象给缓存在redis里，然后每次读写缓存的时候，可以就操作hash里的某个字段。 list：有序列表，可以通过list存储一些列表型的数据结构，类似粉丝列表、文章的评论列表之类的东西。比如可以通过lrange命令，读取某个闭区间内的元素，可以基于list实现分页查询，这个是很棒的一个功能，基于redis实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西，性能高，就一页一页走。 set：是无序集合，自动去重。直接基于set将系统里需要去重的数据扔进去，自动就给去重了，如果你需要对一些数据进行快速的全局去重，你当然也可以基于jvm内存里的HashSet进行去重，但是如果你的某个系统部署在多台机器上呢？得基于redis进行全局的set去重。可以基于set进行交集、并集、差集的操作，比如交集吧，可以把两个人的粉丝列表整一个交集，看看俩人的共同好友是谁？把两个大V的粉丝都放在两个set中，对两个set做交集。 sortedset：sortedset是排序的set，去重但可以排序，写进去的时候给一个分数，自动根据分数排序。获取排名前三的用户（默认是升序，所以需要 rev 改为降序）","categories":[{"name":"服务端","slug":"服务端","permalink":"http://yoursite.com/categories/服务端/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}],"keywords":[{"name":"服务端","slug":"服务端","permalink":"http://yoursite.com/categories/服务端/"}]},{"title":"选择排序","slug":"选择排序","date":"2018-09-28T10:34:01.000Z","updated":"2018-09-28T11:18:04.291Z","comments":true,"path":"2018/09/28/选择排序/","link":"","permalink":"http://yoursite.com/2018/09/28/选择排序/","excerpt":"","text":"选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法。 排序思路对比数组中前一个元素跟后一个元素的大小，如果后面的元素比前面的元素小则用一个变量k来记住他的位置，接着第二次比较，前面“后一个元素”现变成了“前一个元素”，继续跟他的“后一个元素”进行比较如果后面的元素比他要小则用变量k记住它在数组中的位置(下标)，等到循环结束的时候，我们应该找到了最小的那个数的下标了，然后进行判断，如果这个元素的下标不是第一个元素的下标，就让第一个元素跟他交换一下值，这样就找到整个数组中最小的数了。然后找到数组中第二小的数，让他跟数组中第二个元素交换一下值，以此类推。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 选择排序： * 首先，找到数组中最小的那个元素，将它和数组的第一个元素交换位置 * 再次，在剩下元素中找最小的那个元素，将它和数组的第二个元素交换位置 * 以此类推，直到整个数组有序 * * 特点： * ① 运行时间和输入无关 * ② 数据移动是最少的，如果待排序数组长度为 n,只用了n次交换即可完成 */public class 选择排序 &#123; public static void main(String[] args) &#123; int[] arr = &#123;3, 4, 1, 2, 4, 5, 2, 5, 8, 7&#125;; selectionSort(arr); // 结果：[1, 2, 2, 3, 4, 4, 5, 5, 7, 8] System.out.println(Arrays.toString(arr)); &#125; public static void selectionSort(int[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; // 最小元素的索引 int minIndex = i; for (int j = i + 1; j &lt; arr.length; j++) &#123; // 如果后面的元素比当前最小的元素小，临时更新最小索引为 j if (arr[j] &lt; arr[minIndex]) &#123; minIndex = j; &#125; &#125; // 一轮内循环结束后，交换 i 和 最小的 minIndex 的位置 int temp = arr[minIndex]; arr[minIndex] = arr[i]; arr[i] = temp; &#125; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[],"keywords":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}]}]}