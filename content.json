{"meta":{"title":"塔斯特曼-个人博客","subtitle":null,"description":null,"author":"wangyining","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"选择排序","slug":"选择排序","date":"2018-09-28T10:34:01.000Z","updated":"2018-09-28T11:18:04.291Z","comments":true,"path":"2018/09/28/选择排序/","link":"","permalink":"http://yoursite.com/2018/09/28/选择排序/","excerpt":"","text":"选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法。 排序思路对比数组中前一个元素跟后一个元素的大小，如果后面的元素比前面的元素小则用一个变量k来记住他的位置，接着第二次比较，前面“后一个元素”现变成了“前一个元素”，继续跟他的“后一个元素”进行比较如果后面的元素比他要小则用变量k记住它在数组中的位置(下标)，等到循环结束的时候，我们应该找到了最小的那个数的下标了，然后进行判断，如果这个元素的下标不是第一个元素的下标，就让第一个元素跟他交换一下值，这样就找到整个数组中最小的数了。然后找到数组中第二小的数，让他跟数组中第二个元素交换一下值，以此类推。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 选择排序： * 首先，找到数组中最小的那个元素，将它和数组的第一个元素交换位置 * 再次，在剩下元素中找最小的那个元素，将它和数组的第二个元素交换位置 * 以此类推，直到整个数组有序 * * 特点： * ① 运行时间和输入无关 * ② 数据移动是最少的，如果待排序数组长度为 n,只用了n次交换即可完成 */public class 选择排序 &#123; public static void main(String[] args) &#123; int[] arr = &#123;3, 4, 1, 2, 4, 5, 2, 5, 8, 7&#125;; selectionSort(arr); // 结果：[1, 2, 2, 3, 4, 4, 5, 5, 7, 8] System.out.println(Arrays.toString(arr)); &#125; public static void selectionSort(int[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; // 最小元素的索引 int minIndex = i; for (int j = i + 1; j &lt; arr.length; j++) &#123; // 如果后面的元素比当前最小的元素小，临时更新最小索引为 j if (arr[j] &lt; arr[minIndex]) &#123; minIndex = j; &#125; &#125; // 一轮内循环结束后，交换 i 和 最小的 minIndex 的位置 int temp = arr[minIndex]; arr[minIndex] = arr[i]; arr[i] = temp; &#125; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[],"keywords":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}]}]}